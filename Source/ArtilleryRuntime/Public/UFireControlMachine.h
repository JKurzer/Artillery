// Fill out your copyright notice in the Description page of Project Settings.

#pragma once
#include "CoreTypes.h"
#include "CoreMinimal.h"
#include "AbilitySystemComponent.h"
#include "AttributeSet.h"
#include <unordered_map>

#include "GameplayEffectTypes.h"
#include "GameplayEffect.h"
#include "FArtilleryGun.h"
#include "Abilities/GameplayAbility.h"
#include "CanonicalInputStreamECS.h"
#include "ArtilleryDispatch.h"
#include "Containers/CircularQueue.h"
#include <bitset>
#include "ArtilleryCommonTypes.h"
#include "Components/ActorComponent.h"
#include "UFireControlMachine.generated.h"

//dynamic constructed statemachine for matching patterns in action records to triggering abilities.


//Generally, a firecontrolmachine represents a set of guns that share attributes (like ammo!)
// 
//Even then, this attribute set will most often be empty, as we generally want to manage the attributes
//on the actor itself. this will mean we need to think carefully about how to expose the correct attrib set
//down to the blueprint of the abilities themselves. Most characters will have only one FCM.

//The fire control machine is basically one of the pointers to the abilities an actor has, and manages activation patterns.
//it does not interact directly with input or run the patterns itself. that happens on the artillerybusyworker thread.
// 
//Patterns are always run by the artillery worker thread. events generated by pattern success will likely
//run on the tick of either this component or its parent actor for now, but may come to run async if we get lucky.
// 
// Like "Guns," this class mostly exists to hide Artillery complexity from people familiar with GAS already.
// Combined with the ACS, allows you to fully integrate artillery with your existing GAS designs.

UCLASS()
class ARTILLERYRUNTIME_API UFireControlMachine : public UActorComponent
{
	GENERATED_BODY()

public:
	static inline int orderInInitialize = 0;
	UPROPERTY(BlueprintReadOnly)
	UCanonicalInputStreamECS* MySquire;
	ActorKey ParentKey;
	//this needs to be replicated in iris, interestin'ly.
	TSet<FGunKey> MyGuns;
	UArtilleryDispatch* MyDispatch;
	TObjectPtr<UAttributeSet> MyAttributes; // might want to defactor this to an ECS, but I actually quite like it here.
	//still wondering who owns the input streams...
	UAbilitySystemComponent* SystemComponentToBind;
	TMap<FGameplayAbilitySpecHandle, FGameplayAbilitySpec> LiveActivations;
	FireControlKey MyKey;

	//*******************************************************************************************
	//patterns are run in ArtilleryBusyWorker. Search for ARTILLERY_FIRE_CONTROL_MACHINE_HANDLING
	//*******************************************************************************************

	//IF YOU DO NOT CALL THIS FROM THE GAMETHREAD, YOU WILL HAVE A BAD TIME.
	void pushPatternToRunner(TSharedPtr<FActionPattern> ToBind, FActionBitMask ToSeek, FGunKey ToFire)
	{
		FActionPatternParams myParams = FActionPatternParams(ToSeek, MyKey, 0xbeef, ToFire);
		MySquire->registerPattern(ToBind, myParams);
		Arty::FArtilleryFireGunFromDispatch Inbound;
		Inbound.BindUObject(this, &UFireControlMachine::FireGun);
		MyDispatch->RegisterReady(ToFire, Inbound);
		MyGuns.Add(ToFire);
	};

	//IF YOU DO NOT CALL THIS FROM THE GAMETHREAD, YOU WILL HAVE A BAD TIME.
	void popPatternFromRunner(TSharedPtr<FActionPattern> ToBind, FActionBitMask ToSeek, FGunKey ToFire)
	{
		FActionPatternParams myParams = FActionPatternParams(ToSeek, MyKey, 0xbeef, ToFire);
		MySquire->removePattern(ToBind, myParams);
		MyDispatch->Deregister(ToFire);
		MyGuns.Remove(ToFire);


	};


	//IF YOU DO NOT CALL THIS FROM THE GAMETHREAD, YOU WILL HAVE A BAD TIME.
	ActorKey CompleteRegistrationByActorParent(bool IsLocalPlayerCharacter, FArtilleryRunLocomotionFromDispatch LocomotionFromActor)
	{

		//TODO: Find the idiomatic way to do this, cause I'm a liddle worried this could asplode.
		TPair<ActorKey, InputStreamKey> Parent =  MySquire->RegisterKeysToParentActorMapping(GetOwner(), MyKey, true);
		ParentKey = Parent.Key;
		MyDispatch->RegisterLocomotion(ParentKey, LocomotionFromActor);
		
		return ParentKey;
		//likely want to manage system component bind here by checking for actor parent.
		//right now, we can push all our patterns here as well, and we can use a static set of patterns for
		//each of our fire control machines. you can basically think of a fire control machine as a full set
		//of related abilities, their attributes, and similar required to, you know, actually fire a gun.
		//There's a bit more blueprint exposure work to do here as a result.
#ifdef CONTROL_TEST_MODE


#endif
		
	};

	//it is strongly recommended that you understand
	// FGameplayAbilitySpec and FGameplayAbilitySpecDef, as well as Handle.
	// I'm deferring the solve for how we use them for now, in a desperate effort to
	// make sure we can preserve as much of the ability framework as possible
	// but spec management is going to be mission critical for determinism,
	// so we may need to subclass the Ability Component. I'm not looking forward to that.
	void FireGun(TSharedPtr<FArtilleryGun> Gun, bool InputAlreadyUsedOnce)
	{
		/*FGameplayAbilitySpec BackboneFiring =
			SystemComponentToBind->BuildAbilitySpecFromClass(
		(Gun->Prefire).GetClass(),
		0,
		-1
		);
		//TODO: figure out if we want ya boy the Ability system to handle this
		//TODO: And figure out if FCM should really just subclass the ability system component
		//frig.
		FGameplayAbilitySpecHandle FireHandle = BackboneFiring.Handle;
		
		Gun->PreFireGun(FireHandle,
		SystemComponentToBind->AbilityActorInfo.Get(), // why do you even use shared pointers if you're just gonna do this? COME ON.
		FGameplayAbilityActivationInfo(EGameplayAbilityActivationMode::Authority)
		);*/
	};

	void InitializeComponent() override
	{
		Super::InitializeComponent();
		MyKey = UFireControlMachine::orderInInitialize++;

	};
	//this happens post init but pre begin play, and the world subsystems should exist by this point.
	//we use this to help ensure that if the actor's begin play triggers first, things will be set correctly
	//I've left the same code in begin play as a fallback.
	void ReadyForReplication() override
	{
		Super::ReadyForReplication();
		MySquire = GetWorld()->GetSubsystem<UCanonicalInputStreamECS>();
		MyDispatch = GetWorld()->GetSubsystem<UArtilleryDispatch>();
	}
	void BeginPlay() override
	{
		UActorComponent::BeginPlay(); // using this over the looser super atm. TODO: validate!!!!!
		MySquire = GetWorld()->GetSubsystem<UCanonicalInputStreamECS>();
		MyDispatch = GetWorld()->GetSubsystem<UArtilleryDispatch>();
		SystemComponentToBind = GetOwner()->GetComponentByClass<UAbilitySystemComponent>();
		if(SystemComponentToBind == nullptr)
		{
			throw; // Absolutely not. This will never work.
		}
	};

	virtual void OnComponentDestroyed(bool bDestroyingHierarchy) override
	{
		Super::OnComponentDestroyed(bDestroyingHierarchy);
		for (FGunKey Gun : MyGuns)
		{
			MyDispatch->Deregister(Gun); // emergency deregister.
		}
	};
};
